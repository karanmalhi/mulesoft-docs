= DataMapper Flat-to-Structured and Structured-to-Flat Mapping

This document describes how to use Anypoint(TM) DataMapper to map data between a flat format and a structured format. Here you will find two working examples: Mapping from link:/mule-user-guide/v/3.4/datamapper-flat-to-structured-and-structured-to-flat-mapping[CSV to XML] and from link:/mule-user-guide/v/3.4/datamapper-flat-to-structured-and-structured-to-flat-mapping[XML to CSV].

In the first example, the CSV file contains repetitive numbered fields (`address 1` and `address 2`) which we must map to nested structures in the XML file. Likewise, the XML file contains nested structures which we must map to numbered fields in the CSV output file.

To map numbered CSV fields to XML, we will work with mapping levels. To map from XML to numbered CSV fields, we will work with http://en.wikipedia.org/wiki/XPath[XPath] rules.

== CSV to XML

=== Files Used For This Example

==== Input CSV File

*CSV file*:

[source, csv, linenums]
----
Name,Last Name,Street 1,ZipCode 1,Street 2,ZipCode 2
John,Doe,123 Main Street,111,987 Cypress Avenue,222
Jane,Doe,345 Main Street,111,654 Sunset Boulevard,333
----


==== XML Reference File

[source, xml, linenums]
----
<users>
    <user>
        <name></name>
        <lastName></lastName>
        <addresses>
            <address>
                <street></street>
                <zipCode></zipCode>
            </address>
            <address>
                <street></street>
                <zipCode></zipCode>
            </address>
        </addresses>
    </user>
    <user>
        <name></name>
        <lastName></lastName>
        <addresses>
            <address>
                <street></street>
                <zipCode></zipCode>
            </address>           
        </addresses>
    </user>
</users>
----

This example shows how to map the number fields in the link:/mule-user-guide/v/3.4/datamapper-flat-to-structured-and-structured-to-flat-mapping[CSV file] shown above to the link:/mule-user-guide/v/3.4/datamapper-flat-to-structured-and-structured-to-flat-mapping[XML file] shown below it.

We will map the numbered fields `Street` 1 and `Street` 2, and `ZipCode 1` and `ZipCode 2`, to the elements `<street>` and `<zipCode>` in the XML `<address>` element. To do this, we will use mapping levels as shown in the image below.

image:outline-levels.png[outline-levels]

The image above shows the three mapping levels, visable when you click *Element Mapping*.

=== Creating the Example

First, create a new data mapping flow of *Input Type* CSV and *Output Type* XML, using the files provided link:/mule-user-guide/v/3.4/datamapper-flat-to-structured-and-structured-to-flat-mapping[above]. To create new data mapping flow, complete the following steps:

. Create a new Mule project.
. Copy the contents of the link:/mule-user-guide/v/3.4/datamapper-flat-to-structured-and-structured-to-flat-mapping[CSV file] provided for this example to a text file at a convenient location.
. Copy the contents of the link:/mule-user-guide/v/3.4/datamapper-flat-to-structured-and-structured-to-flat-mapping[XML file] provided for this example to a text file at a convenient location.
. In the *Package Explorer* pane, right-click your new Mule project, then select *New*, then *Mapping Flow*. Studio will display the *New Data Mapping Flow* window.

Configure the new data mapping flow according to the parameters listed in the tables below.

Window 1: *New Data Mapping Flow*

[width="100%",cols=",",options="header"]
|===
|Parameter |Value |Remarks |Configuration window image
|*Name:* |`Sample CSV to XML` |Suggested value .3+|image:new.data.mapping.flow-CSV-to-XML.png[new.data.mapping.flow-CSV-to-XML]
|*File name:* | |Auto-completed
|*Description:* | |Optional
|===

Window 2: *Select Input and Output Type*

[width="100%",cols=",",options="header"]
|===
|Parameter |Value |Remarks |Configuration window image
|*Input Type:* |`CSV` | .7+|image:input-output.type-CSV.to.XML.png[input-output.type-CSV.to.XML]
|*From Example / User Defined:* (radio buttons) |`From Example` |
|*CSV Example:* |`<path to CSV file>` |
|*Output Type:* |`XML` |
|*From Example / User Defined:* (radio buttons) |`From Example` |
|*XML Schema:* | |Leave blank
|*Generate schema from xML:* | |Click *Generate schema from XML*
|===

When you click *Generate schema from xml*, Studio displays the *Create xml schema based on XML file* window, outlined below.

Window 3: *Create xml schema based on XML file*

[width="100%",cols=",",options="header"]
|===
|Parameter |Value |Remarks |Configuration window image
|*XML file* |`<path to XML file>` |You can type the full path to your XML file, or click the ellipsis (...) button to browse to and select the file. .2+|image:create.schema.from.xml.png[create.schema.from.xml]
|*Schema directory* | |Auto-completed
|===

After configuring the DataMapper building block, the *Data Mapping View* should look like the image below.

image:csv.to.xml-initial.view.png[csv.to.xml-initial.view]

As you can see, Anypoint DataMapper has automatically created a top-level mapping called Foreach `'contacts' -> 'employees'`. This top-level mapping does not populate any of the desired elements in the output document – there are no elements to be inserted at the top level of this XML document structure. Delete this top-level mapping by clicking the image:remove.map.icon.png[remove.map.icon] icon.

All elements to be populated are at the level of `employee` and `address`, so you will create mappings from the source to those elements. To get started, create a new mapping by clicking the image:add.map.icon.png[add.map.icon] icon. Studio will display the Add Mapping window. Configure the window as outlined in the table below.

Window 4: *Add Mapping*

[width="100%",cols=",",options="header"]
|===
|Parameter |Value |Remarks |Configuration window image
|*Name* |`Employees` |Suggested value .3+|image:add.mapping.1.png[add.mapping.1]
|*Source* |`contacts` |Click `contacts` in the *Source* pane to select
|*Target* |`employee : employeeType` |Click `employee : employeeType` in the *Target* pane to select
|===

After creating the new mapping, the DataMapper view should look like the image below.

image:DM.view.2-csv.to.xml.png[DM.view.2-csv.to.xml]

As you can see, DataMapper mapped the top-level input element contacts to the top-level output element `employee : employeeType`, enabling you to map child elements between the two. DataMapper also auto-mapped the field `Name`, because the name of this field is exactly the same in the input and output.

You now have to manually map the input field `Last Name` to the output field `lastName`. Click the input field, drag it to the output field, and release.

image:lastname.png[lastname]

To map the input fields for the address elements (`Street` and `ZipCode`), you need to create a new mapping level. In this new mapping level, map the input top-level element, contact, to the output element `address : addressType`. To do this, complete the following steps:

. Create a new mapping level by clicking the image:add.map.icon.png[add.map.icon] icon to the right of the *Element Mapping* indicator.
. Studio will display the *Add Mapping* window. Configure the window as outlined in the table below.
+
Window 5: *Add Mapping*
+
[width="100%",cols=",",options="header"]
|===
|Parameter |Value |Remarks |Configuration window image
|*Name* |`Address1` |Suggested value .3+|image:add.mapping.1-2.png[add.mapping.1-2]
|*Source* |`contacts` |Click `contacts` in the *Source* pane to select
|*Target* |`address : addressType` |Click `address : addressType` in the *Target* pane to select
|===
+
After creating the new mapping, the DataMapper view should look like the image below.
+
image:DM.view.3-csv.to.xml.png[DM.view.3-csv.to.xml]

Once you have created the mapping level for addresses, you can map the input fields `Street 1` and `ZipCode 1` to the output fields street and `zipCode`, respectively. This will create one XML `<address>` element that contains elements `<street>` and `<zipCode>`, containing the values of input fields `Street 1` and `ZipCode 1`.

To map the input fields `Street 2` and `ZipCode 2`, create a third mapping level, which in this example we shall name Address2. Then, repeat the steps outlined above to map the input fields `Street 2` and `Zipcode 2` to the ouput element `address : addressType`.

The final mapping should look like the image below. The image shows the third mapping level, `Address2`; mappings for the other mapping levels are shown in grayed-out arrows.

image:DM.view.4-final-csv.to.xml.png[DM.view.4-final-csv.to.xml]

To test your mapping, use the link:/mule-user-guide/v/3.4/datamapper-flat-to-structured-and-structured-to-flat-mapping[Preview] feature by completing the following steps:

. Click *Preview* to access the Preview pane.
. Click *Run*.

The resulting output XML is listed below.

[source, xml, linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<employees>
  <employee>
    <name>John</name>
    <lastName>Doe</lastName>
    <addresses>
      <address>
        <street>123 Main Street</street>
        <zipCode>111</zipCode>
      </address>
      <address>
        <street>987 Cypress Avenue</street>
        <zipCode>222</zipCode>
      </address>
    </addresses>
  </employee>
  <employee>
    <name>Jane</name>
    <lastName>Doe</lastName>
    <addresses>
      <address>
        <street>345 Main Street</street>
        <zipCode>111</zipCode>
      </address>
      <address>
        <street>654 Sunset Boulevard</street>
        <zipCode>333</zipCode>
      </address>
    </addresses>
  </employee>
</employees>
----

== XML to CSV

=== Files Used For This Example

==== Input XML File

[source, xml, linenums]
----
<employees>
    <employee>
        <name>John</name>
        <lastName>Doe</lastName>
        <addresses>
            <address>
                <street>123 Main Street</street>
                <zipCode>111</zipCode>
            </address>
            <address>
                <street>987 Cypress Avenue</street>
                <zipCode>222</zipCode>
            </address>
        </addresses>
    </employee>
    <employee>
        <name>Jane</name>
        <lastName>Doe</lastName>
        <addresses>
            <address>
                <street>345 Main Street</street>
                <zipCode>111</zipCode>
            </address>           
            <address>
                <street>654 Sunset Boulevard</street>
                <zipCode>333</zipCode>
            </address>           
        </addresses>
    </employee>
</employees>
----


==== Example CSV File For Output

*CSV file*:

[source, csv, linenums]
----
Name,Last Name,Street 1,ZipCode 1, Street 2, ZipCode 2
----

In order to map from XML to CSV we will use rules, which we define in DataMapper. These rules use the http://en.wikipedia.org/wiki/XPath[XPath] query language for obtaining nodes in an XML document.

Using XPath, the rules fetch the values of the XML elements that you want, and feed them to DataMapper. DataMapper maps the values to whatever output fields you define in the CSV output file.

image:diagram.png[diagram]

The image above shows how XPath retrieves values stored in XML structures. The XPath expression `/addresses/address[1]/street` retrieves the contents of the street element in the first address element of addresses.

=== Creating the Example

First, create a new data mapping flow of Input Type CSV and Output Type XML, using the files provided link:/mule-user-guide/v/3.4/datamapper-flat-to-structured-and-structured-to-flat-mapping[above]. To create a new data mapping flow, complete the following steps:

. Create a new Mule project.
. Copy the contents of the link:/mule-user-guide/v/3.4/datamapper-flat-to-structured-and-structured-to-flat-mapping[XML file] provided for this example to a text file at a convenient location.
. Copy the contents of the link:/mule-user-guide/v/3.4/datamapper-flat-to-structured-and-structured-to-flat-mapping[CSV file] provided for this example to a text file at a convenient location.
. In the *Package Explorer* pane, right-click your new mule project, then select *New*, then *Mapping Flow*. Studio will display the *New Data Mapping Flow* window.

Configure the new data mapping flow according to the parameters listed in the tables below.

Window 1: *New Data Mapping Flow*

[width="100%",cols=",",options="header"]
|===
|Parameter |Value |Remarks |Configuration window image
|*Name:* |`Sample CSV to XML` |Suggested value .3+|image:1.props.png[1.props]
|*File name:* | |Auto-completed
|*Description:* | |Optional
|===

Window 2: *Select Input and Output Type*

[width="100%",cols=",",options="header"]
|===
|Parameter |Value |Remarks |Configuration window image
|*Input Type:* |`CSV` | .4+|image:input-output.type-CSV.to.XML.png[input-output.type-CSV.to.XML]
|*From Example / User Defined:* (radio buttons) |`From Example` |
|*XML Schema* | |Leave blank
|*Generate schema from xML:* | |Click *Generate schema from XML*
|===

Window 3: *Create xml schema based on XML file*

[width="100%",cols=",",options="header"]
|===
|Parameter |Value |Remarks |Configuration window image
|*XML file* |`<path to XML file>` |You can type the full path to your XML file, or click the ellipsis (...) button to browse to and select the file. .2+|IMAGE MISSING
|*Schema directory* | |Auto-completed
|===

After creating the XML schema, DataMapper configuration takes you back to Window 2, *Select Input and Output Type*, where you must complete the *Output* section.

Window 2: *Select Input and Output Type*

[width="100%",cols=",",options="header"]
|===
|Parameter |Value |Remarks |Configuration window image
|*Output Type:* |`CSV` | .3+|image:2.props-input.png[2.props-input]
|*From Example / User Defined:* (radio buttons) |`From Example` |
|*CSV Example:* |`<path to CSV file>` |
|===

After configuring the DataMapper building block, the *Data Mapping View* should look like the image below.

image:view.1.png[view.1]

As you can see, DataMapper has automatically created a top-level mapping called Foreach `'employees' -> 'contacts'`. Because there are no top-level elements in the source XML document that populate rows in the output CSV document, this mapping is not needed, and in fact it will generate an extra row of output in the CSV if left in place.

Delete this top-level mapping by clicking the [IMAGE MISSING] icon. Then, create a new mapping by clicking the [IMAGE MISSING] icon.

Studio will display the *Add Mapping* window. Configure the window as outlined in the table below.

Window 4: *Add Mapping*

[width="100%",cols=",",options="header"]
|===
|Parameter |Value |Remarks |Configuration window image
|*Name* |`Employees` |Suggested value .3+|image:4.newmap.png[4.newmap]
|*Source* |`employee : employeeType` |Click `employee : employeeType` in the *Target* pane to select
|*Target* |`contacts` |Click `contacts` in the *Source* pane to select
|===

After creating the new mapping, the DataMapper view should look like the image below.

image:view.2.png[view.2]

As you can see, DataMapper mapped the top-level input element `employee : employeeType` to contacts, enabling you to map child elements between the two. DataMapper also mapped the field Name, because the name of this field is exactly the same in the input and output.

You now have to manually map the input field `lastName` to the output field `Last Name`. Click the input field, drag it to the output field, and release.

image:view.3.png[view.3]

To map the addresses in the input XML file to the output CSV fields `Street 1`, `Street 2`, etc., you need to create a rule for the input element address : `addressType`. To create the rule, right-click address : `addressType` in the Input pane, then select *Create Rule based on this element*.

image:create.rule.png[create.rule]

DataMapper will display the *Create a new xpath rule* window. Configure the window as outlined in the table below.

Window 5: *Create xpath rule*

[width="100%",cols=",",options="header"]
|===
|Parameter |Value |Remarks |Configuration window image
|*Name* |`Street1` |Suggested value .5+|image:configure.rule.1.png[configure.rule.1]
|*Type* |`string` |
|*Context* |`/employees/employee` |
|*XPath* |`/addresses/address[1]/street` |
|*Target Field* |`Street 1 : string` |
|===

After creating the rule, the DataMapper view should look like the image below.

image:view.4.png[view.4]

As you can see, DataMapper indicates that the rule `Street1` is in effect for mapping to the output field `Street 1`.

At this point, the output CSV file would be the following:

[source, code, linenums]
----
"Name","Last Name","Street 1","ZipCode 1","Street 2","ZipCode 2"
"John","Doe","123 Main Street","","",""
"Jane","Doe","345 Main Street","","",""
----

We have mapped the street of the first address of the first employee in the input XML file. We now have to create additional rules to map the remaining addresses and their child elements.

Following the procedure outlined above to create XPath rules, create additional rules for the `address : addressType` input element, using the values provided in the table below.

[width="100%",cols=",",options="header"]
|===
|Name (suggested) |Type |Context |XPath |Target field
|`zipCode1` |`string` |`/employee/employee` |`/addresses/address[1]/zipCode` |*ZipCode 1*
|`Street2` |`string` |`/employee/employee` |`/addresses/address[2]/zipCode` |*Street 2*
|`zipCode2` |`string` |`/employee/employee` |`/addresses/address[2]/zipCode` |*ZipCode 2*
|===

Once you have created the rules, you have mapped all of the input elements to their corresponding output elements. The DataMapper view should look like the image below.

image:view.5.png[view.5]

To test your mapping, use the link:/mule-user-guide/v/3.4/datamapper-flat-to-structured-and-structured-to-flat-mapping[Preview] feature by completing the following steps:

. Click *Preview* to go to the Preview pane.
. In the *Input data* field, type the path of the input XML file you prepared for this example, or use the ellipsis (...) button to select the file.
. Click *Run*.

The resulting output CSV file should be the following:

[source, csv, linenums]
----
"Name","Last Name","Street 1","ZipCode 1","Street 2","ZipCode 2"
"John","Doe","123 Main Street","111","987 Cypress Avenue","222"
"Jane","Doe","345 Main Street","111","654 Sunset Boulevard","333"
----

== See Also

* Read about using in-memory databases for flat-file integration in our http://blogs.mulesoft.org/using-in-memory-database-to-help-with-flat-file-integration/[MuleSoft Blog].
